# Database

<details>
<summary>비정규화 va. 비정규화 데이터베이스</summary>

정규화 데이터베이스(nomalized)

- 중복을 최소화하도록 설계된 데이터베이스
- 외래키를 가지고 정보를 한 번만 저장하면 되지만 상당수의 일상적 질의 처리를 위해 조인을 많이 하게 되는 단점

비정규화 데이터베이스(denomalized)

- 읽는 시간을 최적화하도록 설계된 데이터베이스
- 같은 질의를 자주 반복해야 한다면 데이터를 중복해서 저장
- 높은 규모 확장성을 실현하기 위해 자주 사용되는 기법
</details>

.

<details>
<summary>소규모 데이터베이스 설계</summary>

## 1단계: 모호성 처리

설계 시작 전 정확히 무엇을 설계해야 하는지 이해하자

- 드물게 생기는 일은 별도의 방식을 사용해서(DB에 보관된 그 사람의 개인정보를 복사하가나) 해결하자

## 2단계: 핵심 객체 정의

핵심 객체가 무엇인지 살펴보자

- 보통 핵심 객체 하나당 하나의 테이블을 사용

## 3단계: 관계 분석

다대다? 일대다? 테이블 관계 정의하기

## 4단계: 행위 조사

세부적인 부분 채워넣기

- 흔하게 수행될 작업들을 살펴보고, 관련된 데이터를 어떻게 저장하고 가져올 것인지 이해하기
</details>

.

<details>
<summary>대규모 데이터베이스 설계</summary>

대규모의 규모 확장성이 높은 DB 설계 시 Join 연산은 일반적으로 아주 느리다

- 데이터가 어떻게 사용될지 유심히 살펴보고 테이블 비정규화을 적용하자
</details>

.

<details>
<summary>서로 다른 종류의 JOIN은 어떤 것들이 있는가?</summary>

JOIN은 두 테이블을 결합한 결과를 얻을 때 사용된다.

- JOIN 실행을 위해 두 테이블에서 대응되는 레코드들을 찾는 데 쓰일 필드가 하나 이상 있어야 한다.
- JOIN은 어떤 레코드가 결과 테이블에 포함될지에 따라서 여러 가지 부류로 나뉜다.

### 내부 조인(INNER JOIN)

조건에 부합하는 데이터만 결과 집합에 포함

### 외부 조인(OUTER JOIN)

외부 조인 결과 집합에는 내부 조인의 모든 결과가 포함되고, 추가로 조건에 부합하지 않는 레코드도 일부 포함된다.

- 외부 조인에는 `LEFT (OUTER) JOIN`,  `RIGHT (OUTER) JOIN`, `FULL (OUTER) JOIN`

**LEFT (OUTER) JOIN**

왼쪽 테이블의 모든 레코드가 포함

- 오른쪽 테이블에서 대응되는 레코드를 찾지 못할 경우, 그 필드들의 값은 NULL로 채워진다.

**RIGHT (OUTER) JOIN**

좌측 조인의 반대

- 결과 집합에는 오른쪽 테이블의 모든 레코드가 포함
- 왼쪽 테이블에서 대응되는 레코드를 찾지 못한 경우 그 필드의 값은 NULL로 채워진다.
- A, B 테이블이 있을 때, A LEFT JOIN B의 결과는 B RIGHT JOIN A 와 동일하다.

**FULL (OUTER) JOIN**

좌측 조인과 우측 조인의 결과를 결합한 것

- 대응되는 레코드가 있건 없건 두 테이블의 모든 레코드가 결과 집합에 포함된다.
- 대응되는 레코드를 찾지 못한 경우 결과 집합 내의 해당 필드는 NULL로 채워진다.
</details>

.

<details>
<summary>비정규화란 무엇인가?</summary>

비정규화(denormalization)은 하나 이상의 테이블에 데이터를 중복해 배치하는 최적화 기법이다.

- 관계형 데이터베이스를 사용하는 경우, 비정규화를 통해 조인 연산의 비용을 줄일 수 있다.
- 정규화된 데이터베이스의 경우, 데이터의 중복을 가능한 한 최소화하려고 한다. 같은 데이터베이스 내에 하나 정도만 넣으려고 노력한다.

대부분의 대규모 IT 업체의 경우처럼, 규모 확장성을 요구하는 시스템의 경우 거의 항상 정규화된 데이터베이스와 비정규화된 데이터베이스를 섞어 사용한다.

비정규화의 장/단점

| 단점                                                   | 장점                                                                             |
| ------------------------------------------------------ | -------------------------------------------------------------------------------- |
| 데이터 갱신이나 삽입 비용이 높다.                      | 조인 비용이 줄어들기 때문에 데이터 조회가  빠르다.                               |
| 데이터 갱신 또는 삽입 코드를 작성하기가 어려워진다.    | 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단해진다.(버그 가능성 감소) |
| 데이터 간의 일관성이 깨질 수 있다.                     |                                                                                  |
| 데이터를 중복 저장하므로 더 많은 저장 공간이 필요하다. |                                                                                  |
</details>

.